module jmw_1763_7(clk, rst_n, key_in, key_flag, key_state, codeout, Q, CO);

input clk;
input rst_n;
input key_in;

output key_state;
output key_flag;

output CO;
output reg [6:0] codeout;
output reg [3:0] Q;


parameter	S1 = 2'b00;
				S2 = 2'b01;
				S3 = 2'b10;
				S4 = 2'b11;
				
//30ms计数器
reg en_couter;
reg [21:0] cnt;
reg cnt_full;

//计数使能高电平，计数
always @(posedge clk or negedge rst_n)
begin
	if(!rst_n)
		cnt <= 0;
	else if(en_counter)
		cnt <= cnt + 1'b1;
	else
		cnt <= 0;
end

//计数器满信号
always @(posedge clk or negedge rst_n)
begin
	if(!rst_n)
		cnt_full <= 1'b0;
	else if(cnt == 21'd1500000)
		cnt_full <= 1'b1;
	else
		cnt_full <= 1'b0;
end

//判断边沿模块
reg key_tmp0, key_tmp1;

always @(posedge clk or negedge rst_n)
begin
	if(!rst_n)
		begin
			key_tmp0 <= 1'b1;
			key_tmp1 <= 1'b1;
		end

	else
		begin
			key_tmp0 <= key_in;
			key_tmp1 <= key_tmp0;
		end			
end


wire pedge, nedge;
assign pedge = key_tmp0 & (!key_tmp1);
assign nedge = key_tmp1 & (!key_tmp0);


//状态机模块
reg [1:0] state;
reg key_flag;
reg key_state;

always @(posedge clk or negedge rst_n)
begin

if(!rst_n)
	begin
		state			<= S1;
		en_counter	<= 1'b0;
		key_state	<= 1'b1;
		key_flag		<= 1'b0;
	end
else
	case(state)
		S1:
			begin
				en_counter	<= 1'b0;
				key_state	<= 1'b1;
				key_flag		<= 1'b1;
				if(nedge)
					begin
						state			<= S2;
						en_counter	<= 1'b1;
					end
				else state <= state;
			end
		S2:
			if(cnt_full)
				begin
					state			<= S3;
					en_counter	<= 1'b0;
					key_state	<= 1'b0;
					key_flag		<= 1'b0;
				end
			else if(pedge)
				begin
					state			<= S1;
					en_counter	<= 1'b0;
				end
			else state <= state;
		S3:
			begin
				key_flag		<= 1'b0;
				if(pedge)
					begin
						state			<= S4;
						en_counter	<= 1'b1;
					end
				else state <= state;
			end
		S4:
			if(cnt_full)
				begin
					state			<= S1;
					key_state	<= 1'b1;
				end
			else if(nedge)
				begin
					state			<= S3;
					en_counter	<= 1'b0;
				end
			else state <= state;
		default:
			state <= S1;
	endcase;
end


//计数值输出与译码器模块
always @(posedge key_flag, negedge rst_n)
begin
	if(!rst_n)
		Q = 0;
	else
		begin
			if(Q < 4'd12)
				Q <= Q + 1'b1;
			else
				Q <= 4'b1;
		end
end

assign CO = (rst_n & Q == 4'd12);


always @(Q)
begin
	case(Q)
		4'd0 : codeout = 7'b111_1110;
		4'd1 : codeout = 7'b011_0000;
		4'd2 : codeout = 7'b110_1101;
		4'd3 : codeout = 7'b111_1001;
		4'd4 : codeout = 7'b011_0011;
		4'd5 : codeout = 7'b101_1011;
		4'd6 : codeout = 7'b101_1111;
		4'd7 : codeout = 7'b111_0000;
		4'd8 : codeout = 7'b111_1111;
		4'd9 : codeout = 7'b111_1011;
		4'd10 : codeout = 7'b111_0111;
		4'd11 : codeout = 7'b001_1111;
		4'd12 : codeout = 7'b100_1110;
		4'd13 : codeout = 7'b011_1101;
		4'd14 : codeout = 7'b100_1111;
		4'd15 : codeout = 7'b100_0111;
		default: codeout = 7'bx;
	endcase
end

endmodule
