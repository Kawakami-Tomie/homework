C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2024 18:19:15 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "intrins.h"
   3          #include "stdio.h"
   4          unsigned char NixieTable[]={0x3F,0x06,0x5B,
   5          0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
   6          unsigned int count = 0;
   7          unsigned int count1 = 255;
   8          
   9          
  10          #define BUF_SIZE 2  // 缓冲区大小，用于存储接收到的数据  
  11            
  12          unsigned char rx_buffer[BUF_SIZE];  // 接收缓冲区  
  13          unsigned char rx_index = 0;  // 接收缓冲区索引 
  14          
  15          
  16          void Delay(unsigned int xms)
  17          {
  18   1              unsigned char i, j;
  19   1              while(xms--)
  20   1              {
  21   2                      i = 2;
  22   2                      j = 239;
  23   2                      do
  24   2                      {
  25   3                              while (--j);
  26   3                      } while (--i);
  27   2              }
  28   1      }
  29          
  30          void Nixie(unsigned char Location, unsigned char Number)
  31          {
  32   1          switch(Location){
  33   2              case 1: P2_4=0; P2_3=0; P2_2=0; break;
  34   2              case 2: P2_4=0; P2_3=0; P2_2=1; break;
  35   2              case 3: P2_4=0; P2_3=1; P2_2=0; break;
  36   2              case 4: P2_4=0; P2_3=1; P2_2=1; break;     
  37   2              case 5: P2_4=1; P2_3=0; P2_2=0; break;
  38   2              case 6: P2_4=1; P2_3=0; P2_2=1; break;    
  39   2              case 7: P2_4=1; P2_3=1; P2_2=0; break;
  40   2              case 8: P2_4=1; P2_3=1; P2_2=1; break;
  41   2          }
  42   1      
  43   1          P0 = NixieTable[Number];      // 段码输出
  44   1          Delay(1);                                // 显示一段时间
  45   1          P0 = 0x00;                               // 段码清0，消影
  46   1      }
  47          void Uart1_Init(void)   //4800bps@12.000MHz
  48          {
  49   1        
  50   1              PCON |= 0x80;           //使能波特率倍速位SMOD
  51   1              SCON = 0x50;            //8位数据,可变波特率
  52   1              TMOD &= 0x0F;           //设置定时器模式
  53   1              TMOD |= 0x20;           //设置定时器模式
  54   1              TL1 = 0xF3;                     //设置定时初始值
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2024 18:19:15 PAGE 2   

  55   1              TH1 = 0xF3;                     //设置定时重载值
  56   1              ET1 = 0;                        //禁止定时器中断
  57   1              TR1 = 1;                        //定时器1开始计时
  58   1        EA = 1;
  59   1        ES = 1;
  60   1      }
  61          void UART_SendByte(unsigned char Byte)
  62          {
  63   1              SBUF=Byte;
  64   1              while(TI==0);
  65   1              TI=0;
  66   1      }
  67          
  68          void Uart_Isr() interrupt 4 using 1
  69          {
  70   1      //    if (RI==1) {    // 如果接收标志位为1，接收到了数据
  71   1      //       
  72   1      //              
  73   1      //              count = (SBUF-2)/3;
  74   1      
  75   1      ////        UART_SendByte(count);
  76   1      ////        RI=0;    // 接收标志位清0
  77   1      
  78   1      //              RI=0;    // 接收标志位清0
  79   1      //    }
  80   1              
  81   1              
  82   1                  if (RI) {  // 如果接收到数据  
  83   2              RI = 0;  // 清除接收中断标志位  
  84   2              rx_buffer[rx_index++] = SBUF;  // 将接收到的数据存储到缓冲区中  
  85   2              if (rx_index == BUF_SIZE) {  // 如果接收到了足够的字节  
  86   3                  count=(rx_buffer[0]<<8)+rx_buffer[1];// 这里可以添加处理接收到的数据的代码  
  87   3                              count = (count-2)/3;
  88   3                              UART_SendByte(count);
  89   3                  rx_index = 0;  // 重置缓冲区索引，准备接收下一组数据  
  90   3              }  
  91   2          } 
  92   1      }
  93          
  94          
  95          void main()
  96          {
  97   1          Uart1_Init();
  98   1          
  99   1          while(1)
 100   1          {
 101   2             
 102   2                      Nixie(1,count/100);
 103   2                      Nixie(2,count %100/10);
 104   2                      Nixie(3,count%10 );
 105   2                      
 106   2              
 107   2          }
 108   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    311    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17    ----
C51 COMPILER V9.60.0.0   MAIN                                                              04/19/2024 18:19:15 PAGE 3   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
