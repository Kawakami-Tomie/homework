C51 COMPILER V9.60.0.0   MAIN                                                              06/21/2024 16:38:09 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.
                    -\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //#include <REGX52.H>
   2          //#include "intrins.h"
   3          //#include "stdio.h"
   4          //unsigned char NixieTable[]={0x3F,0x06,0x5B,
   5          //0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};
   6          //unsigned int count = 0;
   7          //unsigned int count1 = 255;
   8          
   9          
  10          //#define BUF_SIZE 1  // 缓冲区大小，用于存储接收到的数据  
  11          //  
  12          //unsigned char rx_buffer[BUF_SIZE];  // 接收缓冲区  
  13          //unsigned char rx_index = 0;  // 接收缓冲区索引 
  14          //#define FOSC 12000000L  // 晶振频率12MHz  
  15          //#define BAUD 9600       // 波特率9600  
  16          //  
  17          //// 定时器1重装值（波特率发生器）  
  18          //#define RELOAD_VALUE ((65536 - FOSC / 12 / 32 / BAUD)) 
  19          
  20          
  21          //void Uart1_Init(void) //4800bps@12.000MHz
  22          //{
  23          //  
  24          ////  PCON |= 0x80;   //使能波特率倍速位SMOD
  25          ////  SCON = 0x50;    //8位数据,可变波特率
  26          ////  TMOD &= 0x0F;   //设置定时器模式
  27          ////  TMOD |= 0x20;   //设置定时器模式
  28          ////  TL1 = 0xF3;     //设置定时初始值
  29          ////  TH1 = 0xF3;     //设置定时重载值
  30          ////  ET1 = 0;      //禁止定时器中断
  31          ////  TR1 = 1;      //定时器1开始计时
  32          ////  EA = 1;
  33          ////  ES = 1;
  34          //    TMOD |= 0x20;       // 设置定时器1为模式2（8位自动重装模式）  
  35          //    TH1 = RELOAD_VALUE >> 8; // 设置定时器重装值的高8位  
  36          //    TL1 = RELOAD_VALUE & 0xFF; // 设置定时器重装值的低8位  
  37          //    TR1 = 1;            // 启动定时器1  
  38          //    SCON = 0x50;        // 设置串口为模式1，允许接收（REN=1）  
  39          //    EA = 1;             // 开启全局中断  
  40          //    ES = 1;             // 开启串口中断  
  41          //}
  42          //void UART_SendByte(unsigned char Byte)
  43          //{
  44          //  SBUF=Byte;
  45          //  while(TI==0);
  46          //  TI=0;
  47          //}
  48          
  49          //void Uart_Isr() interrupt 4 using 1
  50          //{
  51          //  
  52          //      if (RI) {  // 如果接收到数据  
  53          //        RI = 0;  // 清除接收中断标志位  
  54          //        rx_buffer[rx_index++] = SBUF;  // 将接收到的数据存储到缓冲区中  
C51 COMPILER V9.60.0.0   MAIN                                                              06/21/2024 16:38:09 PAGE 2   

  55          //        if (rx_index == BUF_SIZE) {  // 如果接收到了足够的字节  
  56          //            count=rx_buffer[0];// 这里可以添加处理接收到的数据的代码 
  57          //        if (count >= 'a' && count <= 'z') {  
  58          //            count = count - 'a' + 'A'; // 将小写字母转为大写  
  59          //        }           
  60          //            UART_SendByte(count);
  61          //            rx_index = 0;  // 重置缓冲区索引，准备接收下一组数据  
  62          //        }  
  63          //    } 
  64          //}
  65          
  66          
  67          //void main()
  68          //{
  69          //    Uart1_Init();
  70          //    
  71          //    while(1)
  72          //    {
  73          
  74          //  
  75          //    }
  76          //}
  77          
  78          
  79          #include <reg51.h>  
  80            
  81          #define FOSC 12000000L  // 晶振频率12MHz  
  82          #define BAUD 9600       // 波特率9600  
  83            
  84          // 定时器1重装值（波特率发生器）  
  85          #define RELOAD_VALUE ((65536 - FOSC / 12 / 32 / BAUD))  
  86            
  87          // 串口初始化函数  
  88          void Serial_Init() {  
  89   1          TMOD |= 0x20;       // 设置定时器1为模式2（8位自动重装模式）  
  90   1          TH1 = RELOAD_VALUE >> 8; // 设置定时器重装值的高8位  
  91   1          TL1 = RELOAD_VALUE & 0xFF; // 设置定时器重装值的低8位  
  92   1          TR1 = 1;            // 启动定时器1  
  93   1          SCON = 0x50;        // 设置串口为模式1，允许接收（REN=1）  
  94   1          EA = 1;             // 开启全局中断  
  95   1          ES = 1;             // 开启串口中断
  96   1      
  97   1        
  98   1      }  
  99            
 100          // 串口接收中断服务程序  
 101          void Serial_ISR() interrupt 4 {  
 102   1          if (RI) {           // 检查接收中断标志  
 103   2              char data_ = SBUF; // 读取接收到的数据  
 104   2              RI = 0;         // 清除接收中断标志  
 105   2        
 106   2              // 数据处理：大写不变，小写变大写，数字不变  
 107   2              if (data_ >= 'a' && data_ <= 'z') {  
 108   3                  data_ = data_ - 'a' + 'A'; // 将小写字母转为大写  
 109   3              }  
 110   2        
 111   2              // 发送处理后的数据  
 112   2              SBUF = data_;  
 113   2              while (!TI);    // 等待发送完成  
 114   2              TI = 0;         // 清除发送中断标志  
 115   2          }  
 116   1      }  
C51 COMPILER V9.60.0.0   MAIN                                                              06/21/2024 16:38:09 PAGE 3   

 117            
 118          void main() {  
 119   1          Serial_Init();      // 初始化串口  
 120   1        
 121   1          while (1) {  
 122   2              // 主程序循环，等待中断发生  
 123   2          }  
 124   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     95    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
