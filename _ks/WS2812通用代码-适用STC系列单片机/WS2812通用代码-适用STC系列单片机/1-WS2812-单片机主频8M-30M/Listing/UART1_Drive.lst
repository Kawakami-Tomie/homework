C51 COMPILER V9.00   UART1_DRIVE                                                           08/08/2019 21:13:30 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE UART1_DRIVE
OBJECT MODULE PLACED IN ..\Objects\UART1_Drive.obj
COMPILER INVOKED BY: D:\keil_v5\C51\BIN\C51.EXE ..\C_AND_H\UART1_Drive.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\C_AND_H) DEB
                    -UG OBJECTEXTEND PRINT(..\Listing\UART1_Drive.lst) TABS(2) OBJECT(..\Objects\UART1_Drive.obj)

line level    source

   1          #include<all.h>
   2          /*表格
   3          ____________________________________________________________________
   4               |    |      |     |         |     |      |      |      |      |
   5          _____|____|______|_____|_________|_____|______|______|______|______|
   6               |    |      |     |         |     |      |      |      |      |
   7          _____|____|______|_____|_________|_____|______|______|______|______|
   8               |    |      |     |         |     |      |      |      |      |
   9          _____|____|______|_____|_________|_____|______|______|______|______|
  10               |    |      |     |         |     |      |      |      |      |
  11          _____|____|______|_____|_________|_____|______|______|______|______|
  12               |    |      |     |         |     |      |      |      |      |
  13          _____|____|______|_____|_________|_____|______|______|______|______|
  14               |    |      |     |         |     |      |      |      |      |
  15          _____|____|______|_____|_________|_____|______|______|______|______|
  16               |    |      |     |         |     |      |      |      |      |
  17          _____|____|______|_____|_________|_____|______|______|______|______|
  18          
  19          */
  20          u8 xdata Uart1_Up_Data_Buffer[30]={"\n\rtemp:23.45 M:45 S:100"};
  21          bit bdata Uart1_Flag=0;
  22          u8 xdata receiv[17]="                 ";
  23          u8 xdata con=0,h;
  24          void UART1_Init()
  25          {
  26   1        SCON|=0X50;//0101 0000
  27   1        AUXR|=0X15;//0001 0101
  28   1      /*
  29   1      ____________________________________________________________________
  30   1      符号 |地址|   B7 |  B6 |    B5   |  B4 |  B3  |  B2  |   B1 |  B0  |
  31   1      AUXR |8EH |T0x12 |T1x12|UART_M0x6| T2R |T2_C/T| T2x12|EXTRAM| S1ST2|
  32   1      SCON |98H |SM0/FE| SM1 |  SM2    | REN | TB8  |  RB8 |  T1  |  RI  |
  33   1      SUBF |99H |      |     |         |     |      |      |      |      |
  34   1      _____|____|______|_____|_________|_____|______|______|______|______|
  35   1        
  36   1      ******AUXR******
  37   1      T2R=1 定时器2开始计数
  38   1      T2_C/T=0 控制定时器0用作定时器或计数器，清0用作定时器，对内部系统进行计数
  39   1      T2x12=1 定时器2速度控制位 1T模式，即CPU时钟不分频 
  40   1      UART_M0x6=0 串口1模式0的波特率不加倍，固定为Focs/12
  41   1      S1ST2=1 选择定时器2作为波特率发射器
  42   1      ******SCON******
  43   1      SM0=0;SM1=1;可变波特率8位数据方式
  44   1      SM2=0;非多机通信方式
  45   1      REN=1;允许串口接收数据
  46   1      ******SUBF******
  47   1      串口1数据接收/发送缓冲区。SUBF实际是2个缓冲器，读缓冲器和写缓冲区，
  48   1      两个操作分别对应两个不同的寄存器，1个是只写寄存器，一个是只读寄存器。
  49   1      对SUBF进行读操作，实际是读取串口接收缓冲区，对SUBF进行写操作则是触发
  50   1      串口开始发送数据。
  51   1      */  
  52   1        T2L=(65536-(FOSC/4/BAUD));     //低
  53   1        T2H=(65536-(FOSC/4/BAUD))>>8;  //高
  54   1      /*ES=1 允许定时器2中断*/
C51 COMPILER V9.00   UART1_DRIVE                                                           08/08/2019 21:13:30 PAGE 2   

  55   1        ES=1;
  56   1        EA=1;
  57   1      }
  58          
  59          void UART1_routine(void) interrupt 4
  60          { 
  61   1          static u8 Uart1_Ser_n=0;
  62   1      /*
  63   1      TI 串口1发送完成中断请求标志。需要软件清0
  64   1      RI 串口1接收完成中断请求标志。需要软件清0
  65   1      */
  66   1          if(RI)
  67   1          {
  68   2              RI=0;
  69   2              if(SBUF)
  70   2              {
  71   3                  if(con==16)
  72   3                  {
  73   4                      for(h=0;h<15;h++)
  74   4                      receiv[h]=receiv[h+1];
  75   4                      receiv[15]=SBUF;
  76   4                  }
  77   3                  else
  78   3                  {
  79   4                      receiv[con]=SBUF;
  80   4                      con++;
  81   4                  }
  82   3                  Change_Dat();
  83   3                  Data_get();
  84   3              }
  85   2              if(SBUF==0x7f)
  86   2              {
  87   3                  Uart1_Ser_n++;
  88   3                  if(Uart1_Ser_n>10)
  89   3                  {
  90   4                      Uart1_Ser_n=0;
  91   4                      IAP_CONTR|=0xe0;
  92   4                  }
  93   3        /*  
  94   3        ___________________________________________________________________________
  95   3        符号      |地址|  B7    |B6   |B5      |  B4     |B3    |B2     |B1   | B0   |
  96   3        __________|____|______|_____|________|_________|______|_______|_____|______|
  97   3        IAP_CONTR |C7H |IAPEN |SWB  |SWRST   |CMD_FAIL |  --  |     IAP_CMD[2:0]   |  
  98   3        __________|____|______|_____|________|_________|______|____________________|
  99   3        复位值0000 x000         
 100   3        SWB=1;   软件复位启动选项
 101   3        软件复位后从系统ISP区开始执行代码。用户数据区的数据会被初始化
 102   3        SWRST=1;  软件复位触发位
 103   3        触发软件复位          
 104   3        */        
 105   3              }
 106   2              else
 107   2              {
 108   3                  Uart1_Ser_n=0;
 109   3              }
 110   2              Uart1_Flag=1;
 111   2            
 112   2          } 
 113   1          else if(TI)
 114   1          {
 115   2              TI=0;
 116   2              Uart1_Flag=1;
C51 COMPILER V9.00   UART1_DRIVE                                                           08/08/2019 21:13:30 PAGE 3   

 117   2          }
 118   1      }
 119          void Uart1_Up_SBUF(u8 k)
 120          {
 121   1          SBUF=Uart1_Up_Data_Buffer[k];
 122   1          Uart1_Flag=0;
 123   1      }
 124          void Uart1_Up_Data_Ser()
 125          {
 126   1        static char xdata count=0;
 127   1        if(Uart1_Flag)
 128   1        {
 129   2            if(count<30)
 130   2            {
 131   3            Uart1_Up_SBUF(count);
 132   3            }
 133   2            else
 134   2            {
 135   3              count=-1;Uart1_Flag=0;
 136   3            }     
 137   2            count++;
 138   2        }
 139   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    251    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     50    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
