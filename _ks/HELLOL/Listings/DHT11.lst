C51 COMPILER V9.60.0.0   DHT11                                                             07/06/2024 21:36:25 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE DHT11
OBJECT MODULE PLACED IN .\Objects\DHT11.obj
COMPILER INVOKED BY: D:\Program Files\Keil_v5\C51\BIN\C51.EXE DHT11.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\DHT11.lst) TABS(2) OBJECT(.\Objects\DHT11.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "DHT11.h"
   3          
   4          #define uchar unsigned char 
   5          #define uint unsigned int
   6          
   7          sbit Data = P3^6;//定义数据线
   8          unsigned char rec_dat[15];   //用于显示的接收数据数组
   9          
  10          /*------------------------------------------------
  11                        DHT11延时函数
  12          ------------------------------------------------*/
  13          void DHT11_delay_us(uchar n)
  14          {
  15   1          while(--n);
  16   1      }
  17           
  18          void DHT11_delay_ms(uint z)
  19          {
  20   1         uint i,j;
  21   1         for(i=z;i>0;i--)
  22   1            for(j=110;j>0;j--);
  23   1      }
  24          /*------------------------------------------------
  25                        DHT11开始信号
  26          ------------------------------------------------*/
  27          void DHT11_start()
  28          {
  29   1         Data=1;
  30   1         DHT11_delay_us(2);
  31   1         Data=0;
  32   1         DHT11_delay_ms(20);   //延时18ms以上
  33   1         Data=1;
  34   1         DHT11_delay_us(30);
  35   1      }
  36          /*------------------------------------------------
  37                        接收八位二进制
  38          ------------------------------------------------*/
  39          uchar DHT11_rec_byte()      //接收一个字节
  40          {
  41   1         uchar i,dat=0;
  42   1        for(i=0;i<8;i++)    //从高到低依次接收8位数据
  43   1         {          
  44   2            while(!Data);   //等待50us低电平过去
  45   2            DHT11_delay_us(8);     //延时60us，如果还为高则数据为1，否则为0 
  46   2            dat<<=1;           //移位使正确接收8位数据，数据为0时直接移位
  47   2            if(Data==1)    //数据为1时，使dat加1来接收数据1
  48   2               dat+=1;
  49   2            while(Data);  //等待数据线拉低    
  50   2          }  
  51   1          return dat;
  52   1      }
  53          /*------------------------------------------------
  54                        接收40bit数据
C51 COMPILER V9.60.0.0   DHT11                                                             07/06/2024 21:36:25 PAGE 2   

  55          ------------------------------------------------*/
  56          void DHT11_receive()      //接收40位的数据
  57          {
  58   1          unsigned char  R_H,R_L,T_H,T_L,RH,RL,TH,TL,revise; 
  59   1          DHT11_start();
  60   1       
  61   1          if(Data==0)
  62   1          {
  63   2        
  64   2              while(Data==0);   //等待拉高     
  65   2          
  66   2              DHT11_delay_us(40);  //拉高后延时80us
  67   2              R_H=DHT11_rec_byte();    //接收湿度高八位  
  68   2              R_L=DHT11_rec_byte();    //接收湿度低八位  
  69   2              T_H=DHT11_rec_byte();    //接收温度高八位  
  70   2              T_L=DHT11_rec_byte();    //接收温度低八位
  71   2              revise=DHT11_rec_byte(); //接收校正位
  72   2             
  73   2              DHT11_delay_us(25);    //结束
  74   2       
  75   2              if((R_H+R_L+T_H+T_L)==revise)      //校正
  76   2              {
  77   3                  RH=R_H;
  78   3                  RL=R_L;
  79   3                  TH=T_H;
  80   3                  TL=T_L;
  81   3              } 
  82   2              /*数据处理，方便显示*/
  83   2              rec_dat[0]='0'+(RH/10);
  84   2              rec_dat[1]='0'+(RH%10);
  85   2          rec_dat[2] =' ';
  86   2          rec_dat[3] = 'R' ;
  87   2          rec_dat[4] = 'H';
  88   2              rec_dat[5]=' ';
  89   2              rec_dat[6]=' ';
  90   2              rec_dat[7]=' ';
  91   2              rec_dat[8]=' ';
  92   2              rec_dat[9]='0'+(TH/10);
  93   2              rec_dat[10]='0'+(TH%10);
  94   2          rec_dat[11] =' ';
  95   2          rec_dat[12] = 'C';
  96   2          rec_dat[13] = ' ' ;
  97   2              rec_dat[14]=' ';
  98   2          }
  99   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    255    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
